<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【算法导论】：B树</title>
      <link href="/2023/01/25/%E3%80%90%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%91%EF%BC%9AB%E6%A0%91/"/>
      <url>/2023/01/25/%E3%80%90%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%91%EF%BC%9AB%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文是《算法导论》的第二篇啃书博客，主要分享B树的各种操作实现，持续更新中！</p><p>B树是为磁盘或其他直接存取的辅助存储设备而设计的一种平衡搜索树。</p><p><strong>B树的性质</strong>：</p><ol><li>如果一个内部节点x包含了n个关键字，那么节点x就有n+1个孩子</li><li>结点x的关键字就是分隔点</li><li>关键字将叶子节点分隔</li><li>每个叶结点具有相同的深度，即树的高度h</li><li>每个结点所包含的关键字个数有上界和下界。称为B树的最小度数<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.312ex;" xmlns="http://www.w3.org/2000/svg" width="4.965ex" height="1.819ex" role="img" focusable="false" viewBox="0 -666 2194.6 804"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mo" transform="translate(638.8,0)"><path data-c="2265" d="M83 616Q83 624 89 630T99 636Q107 636 253 568T543 431T687 361Q694 356 694 346T687 331Q685 329 395 192L107 56H101Q83 58 83 76Q83 77 83 79Q82 86 98 95Q117 105 248 167Q326 204 378 228L626 346L360 472Q291 505 200 548Q112 589 98 597T83 616ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mn" transform="translate(1694.6,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></svg></mjx-container>；除了根节点之外的节点至少有t-1个关键字，因此除了根节点以外的每个内部节点至少有t个孩子。如果树非空，根结点至少有一个关键字；每个结点至多可以包含2t-1个关键字（称为满的full）</li><li>B树的高度：t越大，高度越小。有：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.781ex;" xmlns="http://www.w3.org/2000/svg" width="11.936ex" height="2.746ex" role="img" focusable="false" viewBox="0 -868.9 5275.8 1213.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path></g><g data-mml-node="mo" transform="translate(853.8,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mi" transform="translate(1909.6,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(2207.6,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="msub" transform="translate(2692.6,0)"><g data-mml-node="mi"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"></path></g><g data-mml-node="mi" transform="translate(510,-150) scale(0.707)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(3507.8,0)"><g data-mml-node="mfrac"><g data-mml-node="mrow" transform="translate(220,398) scale(0.707)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(600,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(1378,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mn" transform="translate(707.2,-345) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><rect width="1527.9" height="60" x="120" y="220"></rect></g></g></g></g></svg></mjx-container></li></ol><span id="more"></span><h3 id="B树节点定义："><a href="#B树节点定义：" class="headerlink" title="B树节点定义："></a><strong>B树节点定义</strong>：</h3><ol><li>表示关键字的个数n</li><li>n个关键字本身，以非降序的方式存放</li><li>一个布尔值leaf，判断该节点是否为叶子节点</li><li>有指向孩子节点的指针</li></ol><pre class="language-c++" data-language="c++"><code class="language-c++">template&lt;typename K, typename V&gt;class BTreeNode {// 公有成员public:// 键值对类型using Pair = pair&lt;K, V&gt;;//int n; the number of the keys in this node// bool isLeaf; // 关键字数组vector&lt;Pair&gt; kvs;// kvs.size() return n// 孩子节点vector&lt;BTreeNode&lt;K, V&gt;*&gt; ptrs;// ptrs.empty() return isLeaf// 默认构造函数与析构函数BTreeNode() = default;~BTreeNode() = default;};</code></pre><h3 id="B树完整实现-更新ing"><a href="#B树完整实现-更新ing" class="headerlink" title="B树完整实现(更新ing):"></a><strong>B树完整实现</strong>(更新ing):</h3><pre class="language-c++" data-language="c++"><code class="language-c++"></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 啃书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法导论】：红黑树</title>
      <link href="/2023/01/19/%E3%80%90%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%91%EF%BC%9A%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
      <url>/2023/01/19/%E3%80%90%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%91%EF%BC%9A%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>摸鱼摸了大半个月了，开始学大黑书《算法导论》，从这篇博客开始，后续会不断更新算法导论中比较有用的数据结构或算法的代码部分（主要），理论部分会进行一些讲解，但书上出现过的就不会再重复说明。</p><h3 id="红黑树性质与介绍"><a href="#红黑树性质与介绍" class="headerlink" title="红黑树性质与介绍"></a><strong>红黑树性质与介绍</strong></h3><p>红黑树是一种平衡二叉树的实现方法，相比AVL树，在删除操作中他的统计效率会更高，最多进行三次<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2041 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>的旋转，而AVL树在最坏情况下，旋转的次数为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.695ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3401 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(1450,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mi" transform="translate(1935,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"></path></g><g data-mml-node="mi" transform="translate(2412,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(3012,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>。</p><p>红黑树查找、插入、删除的时间复杂度最坏为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.695ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3401 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(1450,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mi" transform="translate(1935,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"></path></g><g data-mml-node="mi" transform="translate(2412,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(3012,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></p><span id="more"></span><p>红黑树的五个性质：</p><ol><li>每个节点要么是红的，要么是黑的；</li><li>根节点是黑的；</li><li>每个叶子节点（叶子节点即指树尾端NIL指针或NULL结点）都是黑的；</li><li>每个红色节点必须有两个黑色的子节点；</li><li>从任一节点到其每个叶子节点的所有路径都包含相同数目的黑色节点（这个性质保证了：最长路径长度不超过最短路径长度的2倍）</li></ol><p>由于红黑树比较难实现，这里将相关代码也进行部分展示。</p><h3 id="红黑树节点定义"><a href="#红黑树节点定义" class="headerlink" title="红黑树节点定义"></a><strong>红黑树节点定义</strong></h3><p>为方便实现红黑树，这里需要定义五个成员变量，分别为：</p><ol><li>节点颜色</li><li>节点的数据域（这里是实现了类似STL中map的键值对数据域）</li><li>父节点与左右孩子节点</li></ol><pre class="language-c++" data-language="c++"><code class="language-c++">template&lt;typename K, typename V&gt;class RBTreeNode {public:// 键值对类型using Pair = pair&lt;K, V&gt;;// 成员变量Color color;Pair kv;RBTreeNode&lt;K, V&gt;* parent;RBTreeNode&lt;K, V&gt;* left;RBTreeNode&lt;K, V&gt;* right;// 默认构造函数RBTreeNode() :color(Color::RED), kv(make_pair(K(), V())), parent(nullptr), left(nullptr), right(nullptr) {};// 根据键值对的构造函数RBTreeNode(K key, V val) : color(Color::RED), kv(make_pair(key, val)), parent(nullptr), left(nullptr), right(nullptr) {};// 默认新插入的节点都是红色节点};</code></pre><h3 id="红黑树完整实现"><a href="#红黑树完整实现" class="headerlink" title="红黑树完整实现"></a><strong>红黑树完整实现</strong></h3><p><img src="/2023/01/19/%E3%80%90%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%91%EF%BC%9A%E7%BA%A2%E9%BB%91%E6%A0%91/image-20230119144453611.png" alt="image-20230119144453611"></p><p>算法导论中给出了如上的三种数据结构类型，实际实现应选用(a)、(b)两图中的结构，(c)仅是为在书中方便表示而采用的简便写法。为提升数据结构的空间效益，本文使用的结构与(b)图相似，即：节点若没有孩子节点或父节点，则其对应的指针均指向同一个哨兵节点，该哨兵节点为黑色节点。</p><h4 id="旋转操作"><a href="#旋转操作" class="headerlink" title="旋转操作"></a>旋转操作</h4><p>红黑树的旋转操作类似于AVL树，这里不再赘述。</p><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><ol><li>按照二叉平衡树的方式插入红黑树节点（节点默认为红色节点）</li><li>检测新节点的插入是否会影响红黑树的五个性质</li></ol><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>类似于插入操作，但在删除前需要判断待删除节点是否存在，若不存在，应提前返回。</p><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a><strong>完整代码</strong></h4><pre class="language-C++" data-language="C++"><code class="language-C++">template&lt;typename K, typename V&gt;class RBTree {// 公有成员public:// 键值对类型using Pair = pair&lt;K, V&gt;;// 节点指针类型using pointer = RBTreeNode&lt;K, V&gt;*;// 构造函数，起始时，红黑树为空RBTree() {nil = new RBTreeNode&lt;K, V&gt;();nil-&gt;left = nil-&gt;right = nil-&gt;parent = nil;root = nil;nil-&gt;color = Color::BLACK;}// 析构函数~RBTree() {destroy(root);delete nil;nil = nullptr;}// 插入新节点void insert(const K&amp; key, const V&amp; val) {// 指向哨兵与根节点pointer p = nil;pointer s = root;// 遍历到合适的位置while (s != nil) {// 当这次插入的键已经存在过的时候，忽略这次插入if (key == s-&gt;kv.first) return;// p始终设置为s的父节点p = s;if (key &lt; s-&gt;kv.first) s = s-&gt;left;else if (key &gt; s-&gt;kv.first) s = s-&gt;right;}// s此时为nils = new RBTreeNode&lt;K, V&gt;(key, val);s-&gt;left = s-&gt;right = s-&gt;parent = nil;// 当RBTree为空时if (p == nil) {root = s;root-&gt;parent = p;}// 当RBTree不为空时else {if (key &lt; p-&gt;kv.first) p-&gt;left = s;else if (key &gt; p-&gt;kv.first) p-&gt;right = s;s-&gt;parent = p;}// 红黑树平衡insert_fixed(s);}// 插入新节点void insert(K&amp;&amp; key, const V&amp; val) {// 指向哨兵与根节点pointer p = nil;pointer s = root;// 遍历到合适的位置while (s != nil) {// 当这次插入的键已经存在过的时候，忽略这次插入if (key == s-&gt;kv.first) return;// p始终设置为s的父节点p = s;if (key &lt; s-&gt;kv.first) s = s-&gt;left;else if (key &gt; s-&gt;kv.first) s = s-&gt;right;}// s此时为nils = new RBTreeNode&lt;K, V&gt;(key, val);s-&gt;left = s-&gt;right = s-&gt;parent = nil;// 当RBTree为空时if (p == nil) {root = s;root-&gt;parent = p;}// 当RBTree不为空时else {if (key &lt; p-&gt;kv.first) p-&gt;left = s;else if (key &gt; p-&gt;kv.first) p-&gt;right = s;s-&gt;parent = p;}// 红黑树平衡insert_fixed(s);}// 插入新节点void insert(const K&amp; key, V&amp;&amp; val) {// 指向哨兵与根节点pointer p = nil;pointer s = root;// 遍历到合适的位置while (s != nil) {// 当这次插入的键已经存在过的时候，忽略这次插入if (key == s-&gt;kv.first) return;// p始终设置为s的父节点p = s;if (key &lt; s-&gt;kv.first) s = s-&gt;left;else if (key &gt; s-&gt;kv.first) s = s-&gt;right;}// s此时为nils = new RBTreeNode&lt;K, V&gt;(key, val);s-&gt;left = s-&gt;right = s-&gt;parent = nil;// 当RBTree为空时if (p == nil) {root = s;root-&gt;parent = p;}// 当RBTree不为空时else {if (key &lt; p-&gt;kv.first) p-&gt;left = s;else if (key &gt; p-&gt;kv.first) p-&gt;right = s;s-&gt;parent = p;}// 红黑树平衡insert_fixed(s);}// 插入新节点void insert(K&amp;&amp; key, V&amp;&amp; val) {// 指向哨兵与根节点pointer p = nil;pointer s = root;// 遍历到合适的位置while (s != nil) {// 当这次插入的键已经存在过的时候，忽略这次插入if (key == s-&gt;kv.first) return;// p始终设置为s的父节点p = s;if (key &lt; s-&gt;kv.first) s = s-&gt;left;else if (key &gt; s-&gt;kv.first) s = s-&gt;right;}// s此时为nils = new RBTreeNode&lt;K, V&gt;(key, val);s-&gt;left = s-&gt;right = s-&gt;parent = nil;// 当RBTree为空时if (p == nil) {root = s;root-&gt;parent = p;}// 当RBTree不为空时else {if (key &lt; p-&gt;kv.first) p-&gt;left = s;else if (key &gt; p-&gt;kv.first) p-&gt;right = s;s-&gt;parent = p;}// 红黑树平衡insert_fixed(s);}// 删除结点void remove(const K&amp; key) {pointer t;// 查找到指定结点if ((t = search(root, key)) != nil) remove(t);else cout &lt;&lt; "Key is not exist." &lt;&lt; endl;}// 删除结点void remove(K&amp;&amp; key) {pointer t;// 查找到指定结点if ((t = search(root, std::move(key))) != nil) remove(t);else cout &lt;&lt; "Key is not exist." &lt;&lt; endl;}// 查找键值对V find(const K&amp; key) const {return search(root, key)-&gt;kv.second;}// 查找键值对V find(K&amp;&amp; key) const {return search(root, std::move(key))-&gt;kv.second;}// 索引operator[]// 返回键对应的值V&amp; operator[](const K&amp; key) {pointer t = search(root, key);if (t != nil) return t-&gt;kv.second;else {insert(key, std::move(V()));return search(root, key)-&gt;kv.second;}}// 索引operator[]// 返回键对应的值V&amp; operator[](K&amp;&amp; key) {pointer t = search(root, std::move(key));if (t != nil) return t-&gt;kv.second;else {insert(std::move(key), std::move(V()));return search(root, std::move(key))-&gt;kv.second;}}// 打印所有节点void print(void) {show(root);}// 私有成员private:// 根节点pointer root;// 哨兵节点pointer nil;// 析构函数辅助函数void destroy(pointer&amp; node) {if (node == nil) return;if (node-&gt;left != nil) destroy(node-&gt;left);if (node-&gt;right != nil) destroy(node-&gt;right);delete node;node = nullptr;}// 打印函数辅助函数void show(pointer&amp; node) {if (node != nil) {show(node-&gt;left);cout &lt;&lt; "key: " &lt;&lt; node-&gt;kv.first &lt;&lt; ", " &lt;&lt; "value: " &lt;&lt; node-&gt;kv.second &lt;&lt; "; " &lt;&lt; endl;show(node-&gt;right);}}// 左旋转void leftRotation(pointer z) {// 用y指向要转动的z结点pointer y = z-&gt;right;z-&gt;right = y-&gt;left;if (y-&gt;left != nil) y-&gt;left-&gt;parent = z;y-&gt;parent = z-&gt;parent;// 交换y与z位置// 当z就是根节点时if (root == z) root = y;else if (z == z-&gt;parent-&gt;left) z-&gt;parent-&gt;left = y;else z-&gt;parent-&gt;right = y;y-&gt;left = z;z-&gt;parent = y;}// 右旋转void rightRotation(pointer z) {// 用y指向要转动的z结点pointer y = z-&gt;left;z-&gt;left = y-&gt;right;if (y-&gt;right != nil) y-&gt;right-&gt;parent = z;y-&gt;parent = z-&gt;parent;// 交换y与z位置// 当z就是根节点时if (root == z) root = y;else if (z == z-&gt;parent-&gt;left) z-&gt;parent-&gt;left = y;else z-&gt;parent-&gt;right = y;y-&gt;right = z;z-&gt;parent = y;}// 插入后的调整函数void insert_fixed(pointer s) {// 叔节点pointer uncle;// 父节点为红色while (s-&gt;parent-&gt;color == Color::RED) {// 父节点是左结点if (s-&gt;parent == s-&gt;parent-&gt;parent-&gt;left) {uncle = s-&gt;parent-&gt;parent-&gt;right;// 叔节点也是红色if (uncle-&gt;color == Color::RED) {// 父节点和叔节点都变为黑色s-&gt;parent-&gt;color = Color::BLACK;uncle-&gt;color = Color::BLACK;// 祖父结点变成红色s-&gt;parent-&gt;parent-&gt;color = Color::RED;// s指针指向祖父结点，下一次循环判断祖父结点的父节点是否为红色s = s-&gt;parent-&gt;parent;}// 没有叔节点或叔节点为黑色else {// 调整的节点为右结点if (s == s-&gt;parent-&gt;right) {// 左转父节点s = s-&gt;parent;leftRotation(s);}// 若调整的节点在左节点，将父节点变为黑色，祖父结点变成红色，再右转祖父结点s-&gt;parent-&gt;color = Color::BLACK;s-&gt;parent-&gt;parent-&gt;color = Color::RED;rightRotation(s-&gt;parent-&gt;parent);}}else {// 父节点为右节点if (s-&gt;parent == s-&gt;parent-&gt;parent-&gt;right) {uncle = s-&gt;parent-&gt;parent-&gt;left;// 叔节点也是红色if (uncle-&gt;color == Color::RED) {// 父节点和叔节点都变为黑色s-&gt;parent-&gt;color = Color::BLACK;uncle-&gt;color = Color::BLACK;// 祖父结点变成红色s-&gt;parent-&gt;parent-&gt;color = Color::RED;// s指针指向祖父结点，下一次循环判断祖父结点的父节点是否为红色s = s-&gt;parent-&gt;parent;}// 没有叔节点else {if (s == s-&gt;parent-&gt;left) {s = s-&gt;parent;rightRotation(s);}s-&gt;parent-&gt;color = Color::BLACK;s-&gt;parent-&gt;parent-&gt;color = Color::RED;leftRotation(s-&gt;parent-&gt;parent);}}}}// 根节点始终为黑色root-&gt;color = Color::BLACK;}// 内部查找函数pointer search(pointer node, const K&amp; key) const {// 结点为空if (node == nil) return nil;// 以大小来判断if (node-&gt;kv.first == key) return node;if (key &lt; node-&gt;kv.first) return search(node-&gt;left, key);if (key &gt; node-&gt;kv.first) return search(node-&gt;right, key);}// 内部查找函数pointer search(pointer node, K&amp;&amp; key) const {// 结点为空if (node == nil) return nil;// 以大小来判断if (node-&gt;kv.first == key) return node;if (key &lt; node-&gt;kv.first) return search(node-&gt;left, std::move(key));if (key &gt; node-&gt;kv.first) return search(node-&gt;right, std::move(key));}// 最大元素的指针pointer maximum(pointer x) {if (x-&gt;right == nil) return x;return maximum(x-&gt;right);}// 最小元素的指针pointer minimum(pointer x) {if (x-&gt;left == nil) return x;return minimum(x-&gt;left);}// 将u的子节点指向u的指针改变指向v，将v的父节点指针改变指向u的父节点void transplant(pointer u, pointer v) {// 指针改变指向if (u-&gt;parent == nil) root = v;else if (u == u-&gt;parent-&gt;left) u-&gt;parent-&gt;left = v;else u-&gt;parent-&gt;right = v;v-&gt;parent = u-&gt;parent;}// 内部删除函数void remove(pointer z) {pointer x = nil;pointer y = z;Color ycolor = y-&gt;color;// z只有右孩子if (z-&gt;left = nil) {x = z-&gt;right;transplant(z, z-&gt;right);}// z只有左孩子else if (z-&gt;right == nil) {x = z-&gt;left;transplant(z, z-&gt;left);}else {y = minimum(z-&gt;right);ycolor = y-&gt;color;x = y-&gt;right;if (y-&gt;parent == z) x-&gt;parent = y;else {transplant(y, y-&gt;right);y-&gt;right = z-&gt;right;y-&gt;right-&gt;parent = y;}transplant(z, y);// 改变指向y-&gt;left = z-&gt;left;z-&gt;left-&gt;parent = y;y-&gt;color = z-&gt;color;}if (ycolor == Color::BLACK) remove_fixed(x);}//红黑树删除调整void remove_fixed(pointer x) {//当结点x不为根并且它的颜色不是黑色while (x != root &amp;&amp; x-&gt;color == Color::BLACK) {//x在左子树if (x == x-&gt;parent-&gt;left) {//w是x的兄结点pointer w = x-&gt;parent-&gt;right; //情况1if (w-&gt;color == Color::RED) {w-&gt;color = Color::BLACK;x-&gt;parent-&gt;color = Color::RED;leftRotation(x-&gt;parent);w = x-&gt;parent-&gt;right;}//情况2if (w-&gt;left-&gt;color == Color::BLACK &amp;&amp; w-&gt;right-&gt;color == Color::BLACK) {w-&gt;color = Color::RED;x = x-&gt;parent;}else {//情况3if (w-&gt;right-&gt;color == Color::BLACK) {w-&gt;color = Color::RED;w-&gt;left-&gt;color = Color::BLACK;rightRotation(w);w = x-&gt;parent-&gt;right;}//情况4w-&gt;color = w-&gt;parent-&gt;color;w-&gt;parent-&gt;color = Color::BLACK;w-&gt;right-&gt;color = Color::BLACK;leftRotation(x-&gt;parent);x = root; //结束循环}}// x在右子树else {pointer w = x-&gt;parent-&gt;left;//情况1if (w-&gt;color == Color::RED) {w-&gt;parent-&gt;color = Color::RED;w-&gt;color = Color::BLACK;rightRotation(x-&gt;parent);w = x-&gt;parent-&gt;left;}//情况2if (w-&gt;right-&gt;color == Color::BLACK &amp;&amp; w-&gt;right-&gt;color == Color::BLACK) {w-&gt;color = Color::RED;x = x-&gt;parent;}else {//情况3if (w-&gt;left-&gt;color == Color::BLACK) {w-&gt;right-&gt;color = Color::BLACK;w-&gt;color = Color::RED;leftRotation(w);w = x-&gt;parent-&gt;left;}//情况4w-&gt;color = x-&gt;parent-&gt;color;x-&gt;parent-&gt;color = Color::BLACK;w-&gt;left-&gt;color = Color::BLACK;rightRotation(x-&gt;parent);x = root; //结束循环}}}// 改变颜色x-&gt;color = Color::BLACK;}};</code></pre><p>PS：具体理论请参考算法导论第174~192页</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 啃书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考试摸鱼记</title>
      <link href="/2022/12/22/%E8%80%83%E8%AF%95%E6%91%B8%E9%B1%BC%E8%AE%B0/"/>
      <url>/2022/12/22/%E8%80%83%E8%AF%95%E6%91%B8%E9%B1%BC%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>现在是2022年12月22日下午15点55分，在这里先祝大家冬至快乐！！！又快到新的一年长大一岁啦！</p><p>虽然但是，大一期末人现在还在期末周复习阶段，现在也刚好是我的第一科考试，程序设计基础实验，距离我答完题已经过去了半个多小时。现在由于是线上考试非常的无聊非常的困。我决定给自己找点事情做，那就是来码这篇博客。</p><span id="more"></span><p>没想到第一篇生活类blog来得这么快，现在是一个又困又不能睡觉的状态。</p><p>由于疫情原因，我们考试都是线上进行（有的学校等到下学期才考试真的很羡慕），家里也有已经阳性的人所以也挺害怕自己在考试周倒下了。</p><p>希望冬至过后，疫情退散，新的一年大家都能好起来！！！</p><p>待会可能还要留点时间检查所以就不写太多了，这个博客还是要以技术为主（）也把考试题目放上来吧。</p><img src="/2022/12/22/%E8%80%83%E8%AF%95%E6%91%B8%E9%B1%BC%E8%AE%B0/期末试题.png" alt="期末试题" style="zoom:38%;"><h5 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a><strong>题目一</strong></h5><p>这题还挺见的，有点歧义。</p><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;double x;// 获取手续费的函数double getSub(double x) {if (x &lt;= 2000) return 0;else if (x &lt;= 5000) return 0.05 * (x - 2000);else if (x &lt;= 10000) return 0.1 * (x - 5000) + getSub(5000);else return 0.15 * (x - 10000) + getSub(10000);}// 这里题目有歧义// 到底是超过了金额就直接按照该金额的百分比去算// 或者是超出部分按超出部分计算，未超出部分按未超出指定金额去算// 如果是第一种算法的话，2001获取的实际收入小于2000的实际收入(这显然不合理)// 因此我们按照第二种算法计算手续费int main(void) {// 1. 显示手续费的收取标准cout &lt;&lt; "金额2000元以下，不收手续费" &lt;&lt; endl;cout &lt;&lt; "金额2001元-5000元，按5%收取" &lt;&lt; endl;cout &lt;&lt; "金额5001元-10000元，按10%收取" &lt;&lt; endl;cout &lt;&lt; "金额10000元以上，按15%收取" &lt;&lt; endl;// 输入cout &lt;&lt; "请输入业务收入：" &lt;&lt; endl;cin &gt;&gt; x;// 2. 显示业务金额、对应的手续费和实际收入cout &lt;&lt; "业务金额：" &lt;&lt; x &lt;&lt; endl;double sub = getSub(x);cout &lt;&lt; "对应的手续费：" &lt;&lt; sub &lt;&lt; endl;cout &lt;&lt; "实际收入：" &lt;&lt; x - sub &lt;&lt; endl;return 0;}</code></pre><h5 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a><strong>第二题</strong></h5><p>这题也见，也有歧义！</p><p>这里a如果不是个位数咋办？</p><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;int n, a;// 求x的位数int digit(int x) {int dig = 0;for (; x; x /= 10, ++dig);return dig;}// 求sint getS(int a, int n) {int s = a;int tmp = a;// a可能不是个位数int dig = digit(a);while (--n) {// tmp为新增的每一项tmp *= pow(10, dig);tmp += a;// 累加至s中s += tmp;}return s;}int main(void) {cout &lt;&lt; "请分别输入n和a：" &lt;&lt; endl;cin &gt;&gt; n &gt;&gt; a;// 输入非法while (n &lt;= 0 || a &lt;= 0) {cout &lt;&lt; "输入非法，请重新输入：" &lt;&lt; endl;cin &gt;&gt; n &gt;&gt; a;}// 显示计算后的值cout &lt;&lt; "s的值等于：" &lt;&lt; endl;cout &lt;&lt; getS(a, n) &lt;&lt; endl;return 0;}</code></pre><h5 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a><strong>第三题</strong></h5><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;int a[6], x;void insert(int* a, int x) {// 找到要插入的位置int idx;for (idx = 0; idx &lt; 5; ++idx) {if (a[idx] &gt; x) break;}// 向后移动一位for (int i = 4; i &gt;= idx; --i) a[i + 1] = a[i];// 将新数据插入指定位置a[idx] = x;}int main(void) {// 输入原数组cout &lt;&lt; "请输入从小到大顺序的5个整数:" &lt;&lt; endl;for (int i = 0; i &lt; 5; ++i) cin &gt;&gt; a[i];// 输出原数组cout &lt;&lt; "原数组:" &lt;&lt; endl;for (int i = 0; i &lt; 5; ++i) cout &lt;&lt; a[i] &lt;&lt; ' ';cout &lt;&lt; endl;// 输入插入元素并插入数组中cout &lt;&lt; "请输入你要插入的元素:" &lt;&lt; endl;cin &gt;&gt; x;insert(a, x);// 输出插入后的数组cout &lt;&lt; "插入后的数组" &lt;&lt; endl;for (int i = 0; i &lt; 6; ++i) cout &lt;&lt; a[i] &lt;&lt; ' ';return 0;}</code></pre><p><del>没有出乎我的意料，有歧义，简单但恶心你，让你在出分前睡不好觉</del></p><p>第三题本来还想写个二分，想了想还是不炫技了。</p><p>好啦摸鱼结束！开始检查然后交卷啦！！！</p><hr><p>update: 2022/12/22 16:56</p><p>考完问了对象and几个朋友，确实分成了两波人，所以是题目问题。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> 摸鱼 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客</title>
      <link href="/2022/12/18/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2022/12/18/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本博客主要写: 对此博客创建的初衷与对笔者自己的介绍。<br>一个来自某某师专的菜鸟ACMer，创建此博客的初衷是分享学习与生活、解决各种问题的过程。</p><h3 id="个人介绍"><a href="#个人介绍" class="headerlink" title="个人介绍"></a><strong>个人介绍</strong></h3><p>本人是来自某某师专（bushi）的学生，专业是计算机科学与技术，在编写此博客时，是一名大一的本科学生。</p><p>已经参与过数学建模、ICPC等ACM竞赛、CTF竞赛，并且在逐步学习前后端开发知识，对人工智能也颇有兴趣。 创建本博客也正是为了记录各类知识学习的过程。</p><p>编写此博客时，笔者正在学习SpringBoot与Vue框架，希望能成为一个不写屎山代码的全栈程序员。同时，算法的学习不会停下脚步，正在codeforces、Acwing、洛谷等平台进行算法的学习。</p><p>由于本人恋爱脑的性格，所以说不定会（肯定会）在这里分享一些恋爱日常。（小狗饼too可爱！）</p><span id="more"></span><h3 id="一些计划"><a href="#一些计划" class="headerlink" title="一些计划"></a><strong>一些计划</strong></h3><p>顺便在这里定一下学习计划吧！！！</p><ol><li>算法算法！！！为了CCPC和ICPC！！！（还有蓝桥杯的3伯块）</li><li>java要学习一些底层知识，了解spring框架的底层与部分源码</li><li>离散数学，更准确一点应该是数论方面，为了学好算法的必经之路</li><li>人工智能方面也想有所涉猎，毕竟大势所趋</li></ol><p>长期计划！！！</p><ol><li>搞钱</li><li>恋爱同居！</li></ol><h3 id="此博客内容"><a href="#此博客内容" class="headerlink" title="此博客内容"></a><strong>此博客内容</strong></h3><p>大概想了一些模块：</p><ol><li>算法模块（大概是算法知识与一些算法题的题解）</li><li>编程语言模块（目前笔者只学习了C/C++、Python、Java、MATLAB、JavaScript这些编程语言）</li><li>前端技术模块（会与JavaScript有所重合、Vue框架以及相应的技术栈）</li><li>后端技术模块（SpringBoot框架与服务端知识）</li><li>人工智能模块（正在学习的机器学习算法与后续会学习的人工智能相关知识）</li><li>竞赛模块（分享竞赛日常与相应的知识）</li><li>数学基础模块（上面各个模块的数学基础知识）</li><li>啃书系列（大概就是自己啃书的一些过程）</li><li>分享系列（分享好书、好用软件、甚至是生活中遇到的goodgoodthing等等）</li><li>恋爱！！！（更新一点with小狗饼）</li><li>生活blog（不好说会更新什么）</li><li>等内容……</li></ol><h3 id="博客技术栈"><a href="#博客技术栈" class="headerlink" title="博客技术栈"></a><strong>博客技术栈</strong></h3><ol><li>Hexo博客框架</li><li>Aomori博客主题</li><li>live2d看板娘</li><li>gitalk评论组件</li><li>algolia搜索组件</li><li>ionicons图标组件</li></ol><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a><strong>联系方式</strong></h3><p>由于本人技术方面有所欠缺，博客内容若有纰漏，欢迎批评指正！（评论或添加我的微信——务必备注来意！！！）</p><img src="/2022/12/18/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/wechat.jpg" alt="f4e7fab9e8e418935d2d0e1619b3d5e" style="zoom: 33%;">]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 介绍 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
